Comparing C:\Users\ngoqu\Documents\GitHub\stm32c8\STM32C8vsW5500 UDP\HARDWARE\W5500\W5500.c and C:\Users\ngoqu\Documents\GitHub\stm32c8\STM32C8vsW5500 UDP - Copy\HARDWARE\W5500\W5500.c
  /**********************************************************************************
  W5500ÍøÂçÄ£¿é Ö÷´úÂë
  
  **********************************************************************************/
  
  #include "stm32f10x.h"
  #include "spi.h"
  #include "W5500.h"
  #include "delay.h"
  
I !> //Network parameter variable definition
I !> u8 Gateway_IP[4];//Gateway IP address
I !> u8 Sub_Mask[4];	//Subnet mask
I !> u8 Phy_Addr[6];	//Physical address (MAC)
I !> u8 IP_Addr[4];	//Local IP address
  
D <! //ÍøÂç²ÎÊı±äÁ¿¶¨Òå
D <! u8 Gateway_IP[4];//Íø¹ØIPµØÖ·
D <! u8 Sub_Mask[4];	//×ÓÍøÑÚÂë
D <! u8 Phy_Addr[6];	//ÎïÀíµØÖ·(MAC)
D <! u8 IP_Addr[4];	//±¾»úIPµØÖ·
I !> u8 S0_Port[2];	//Port number of port 0
I !> u8 S0_DIP[4];	//Port 0 destination IP address
I !> u8 S0_DPort[2];	//Port 0 destination port number
  
D <! u8 S0_Port[2];	//¶Ë¿Ú0µÄ¶Ë¿ÚºÅ(5000)
D <! u8 S0_DIP[4];	//¶Ë¿Ú0Ä¿µÄIPµØÖ·
D <! u8 S0_DPort[2];	//¶Ë¿Ú0Ä¿µÄ¶Ë¿ÚºÅ(6000)
I !> u8 UDP_DIPR[4];	    //UDP(Broadcast mode, destination host IP address
I !> u8 UDP_DPORT[2];	//UDP(Broadcast) mode, destination host port number
  
D <! u8 UDP_DIPR[4];	    //UDP(¹ã²¥)Ä£Ê½,Ä¿µÄÖ÷»úIPµØÖ·
D <! u8 UDP_DPORT[2];	//UDP(¹ã²¥)Ä£Ê½,Ä¿µÄÖ÷»ú¶Ë¿ÚºÅ
  
I !> //Port operating mode
I !> u8 S0_Mode =3;	            //Port 0 operating mode, 0: TCP server mode, 1: TCP client mode, 2: UDP (broadcast) mode
I !> #define TCP_SERVER	0x00	//TCP Server mode
I !> #define TCP_CLIENT	0x01	//TCP Client mode
I !> #define UDP_MODE	0x02	//UDP (broadcast) mode
  
D <! //¶Ë¿ÚµÄÔËĞĞÄ£Ê½
D <! u8 S0_Mode =3;	            //¶Ë¿Ú0µÄÔËĞĞÄ£Ê½,0:TCP·şÎñÆ÷Ä£Ê½,1:TCP¿Í»§¶ËÄ£Ê½,2:UDP(¹ã²¥)Ä£Ê½
D <! #define TCP_SERVER	0x00	//TCP·şÎñÆ÷Ä£Ê½
D <! #define TCP_CLIENT	0x01	//TCP¿Í»§¶ËÄ£Ê½
D <! #define UDP_MODE	0x02	//UDP(¹ã²¥)Ä£Ê½
I !> //Socket status ?
I !> //#define S_Unknown 0x00  //Khong ro trang thai
I !> //#define S_INIT		0x01	//Port completion initialization
I !> //#define S_CONN		0x02	//Port complete connection,Can transfer data normally
I !> u8 S0_State = S_Unknown;	            //Port 0 status record, 1: port complete initialization, 2 ports complete connection (can transfer data normally)
  
D <! //¶Ë¿ÚµÄÔËĞĞ×´Ì¬
D <! u8 S0_State =0;	            //¶Ë¿Ú0×´Ì¬¼ÇÂ¼,1:¶Ë¿ÚÍê³É³õÊ¼»¯,2¶Ë¿ÚÍê³ÉÁ¬½Ó(¿ÉÒÔÕı³£´«ÊäÊı¾İ)
D <! #define S_INIT		0x01	//¶Ë¿ÚÍê³É³õÊ¼»¯
D <! #define S_CONN		0x02	//¶Ë¿ÚÍê³ÉÁ¬½Ó,¿ÉÒÔÕı³£´«ÊäÊı¾İ
I !> //Status of the port to send and receive data
I !> u8 S0_Data;	               	//Port 0 receives and sends data status, 1: port receives data, 2: port sends data completed
I !> #define S_RECEIVE	 0x01	//The port received a packet
I !> #define S_TRANSMITOK 0x02	//The port sends a packet to complete
  
D <! //¶Ë¿ÚÊÕ·¢Êı¾İµÄ×´Ì¬
D <! u8 S0_Data;	               	//¶Ë¿Ú0½ÓÊÕºÍ·¢ËÍÊı¾İµÄ×´Ì¬,1:¶Ë¿Ú½ÓÊÕµ½Êı¾İ,2:¶Ë¿Ú·¢ËÍÊı¾İÍê³É
D <! #define S_RECEIVE	 0x01	//¶Ë¿Ú½ÓÊÕµ½Ò»¸öÊı¾İ°ü
D <! #define S_TRANSMITOK 0x02	//¶Ë¿Ú·¢ËÍÒ»¸öÊı¾İ°üÍê³É
I !> //Port data buffer
I !> u8 Rx_Buffer[2048];	//Port receive data buffer
I !> u8 Tx_Buffer[2048];	//Port send data buffer
  
D <! //¶Ë¿ÚÊı¾İ»º³åÇø
D <! u8 Rx_Buffer[2048];	//¶Ë¿Ú½ÓÊÕÊı¾İ»º³åÇø
D <! u8 Tx_Buffer[2048];	//¶Ë¿Ú·¢ËÍÊı¾İ»º³åÇø
I !> u8 W5500_Interrupt;	//W5500 interrupt flag (0: no interrupt, 1: interrupt)
  
D <! u8 W5500_Interrupt;	//W5500ÖĞ¶Ï±êÖ¾(0:ÎŞÖĞ¶Ï,1:ÓĞÖĞ¶Ï)
D <! 
  
  
  
  
  
  
  //W5500¸÷¶Ë¿Ú³õÊ¼»¯¼°ÅäÖÃÖĞ¶ÏÄ£Ê½
  //ÏàÓ¦ÅäÖÃËµÃ÷£º
  //sck PA5  miso PA6  mosi PA7  rst PA2  int PA3  cs PA0
  void W5500_GPIO_Init(void)
  {
  GPIO_InitTypeDef  GPIO_InitStructure;
  
  EXTI_InitTypeDef EXTI_InitStructure;			//ÖĞ¶ÏÅäÖÃ	  ¼´ÄÄ¸öÖĞ¶ÏÏß  EXTI_Line0-15
  //Ä£Ê½ EXTI_Mode_InterruptÖĞ¶Ï  EXTI_Mode_Event ÊÂ¼ş
  //´¥·¢·½Ê½  EXTI_Trigger_Falling ÏÂ½µÑØ´¥·¢
  //			EXTI_Trigger_Rising	 ÉÏÉıÑØ´¥·¢
  //			EXTI_Trigger_Rising_Falling	  ÈÎÒâµçÆ½´¥·¢
  
  NVIC_InitTypeDef NVIC_InitStructure;			//ÖĞ¶Ï²ÎÊı ÖĞ¶ÏÓÅÏÈ¼¶
  
  
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);	//Ê¹ÄÜ¸´ÓÃ¹¦ÄÜÊ±ÖÓ
  
  
  
  RCC_APB2PeriphClockCmd(	RCC_APB2Periph_GPIOA, ENABLE );//PORTBÊ±ÖÓÊ¹ÄÜ
  
  
  // W5500_RSTÒı½Å³õÊ¼»¯ÅäÖÃ(PA2)
  GPIO_InitStructure.GPIO_Pin  = W5500_RST;
  GPIO_InitStructure.GPIO_Speed=GPIO_Speed_10MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(W5500_RST_GPIO, &GPIO_InitStructure);
  GPIO_ResetBits(W5500_RST_GPIO, W5500_RST);
  
  // W5500_INTÒı½Å³õÊ¼»¯ÅäÖÃ(PA3)
  GPIO_InitStructure.GPIO_Pin = W5500_INT;
  GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_Init(W5500_INT_GPIO, &GPIO_InitStructure);
  
  
  // ³õÊ¼»¯ÍøÂçÄ£¿éSPI-CSÒı½Å (PA0)
  GPIO_InitStructure.GPIO_Pin = W5500_SCS;
  GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
  GPIO_Init(W5500_SCS_GPIO, &GPIO_InitStructure);
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS);
  
  
  
  // Enable the EXTI3 Interrupt
  NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;				//W5500_INTËùÔÚµÄÍâ²¿ÖĞ¶ÏÍ¨µÀ
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;	//ÇÀÕ¼ÓÅÏÈ¼¶2£¬
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;			//×ÓÓÅÏÈ¼¶2
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;					//Ê¹ÄÜÍâ²¿ÖĞ¶ÏÍ¨µÀ
  NVIC_Init(&NVIC_InitStructure);
  
  
  // Connect EXTI Line3 to PA3
  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource3);
  
  
  // PA3 as W5500 interrupt input
  EXTI_InitStructure.EXTI_Line = EXTI_Line3;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);
  
  }
  
  
  //ÖĞ¶ÏÏß3  PA3ÏìÓ¦ W5500À´µÄÊı¾İ ²¢ÖÃÒ»±êÖ¾Î»
  void EXTI3_IRQHandler(void)
  {
  if(EXTI_GetITStatus(EXTI_Line3) != RESET)
  {
  EXTI_ClearITPendingBit(EXTI_Line3);	//ÇåÖĞ¶ÏÏß
  W5500_Interrupt=1;
  }
  }
  
  
  
  //Í¨¹ıSPI1·¢ËÍÒ»¸ö×Ö½Ú
  //dat ·¢ËÍµÄ×Ö½Ú
  //ÎŞ·µ»Ø
  void SPI1_Send_Byte(u8 dat)
  {
  SPI_I2S_SendData(SPI1,dat);//Ğ´1¸ö×Ö½ÚÊı¾İ
  while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);//ËÀÑ­»·µÈ´ıÊı¾İ¼Ä´æÆ÷¿Õ
  }
  
  
  
  //PI1·¢ËÍ2¸ö×Ö½ÚÊı¾İ(16Î»)
  //dat:´ı·¢ËÍµÄ16Î»Êı¾İ
  void SPI1_Send_Short(u16 dat)
  {
D <! SPI1_Send_Byte(dat/256);//Ğ´Êı¾İ¸ßÎ»   Ïàµ±ÓÚdat>>8
I !> SPI1_Send_Byte(dat>>8);//Ğ´Êı¾İ¸ßÎ»   Ïàµ±ÓÚdat>>8
  SPI1_Send_Byte(dat);	//Ğ´Êı¾İµÍÎ»
  }
  
  
  
  
  //Í¨¹ıSPI1ÏòW5500Ö¸¶¨µØÖ·¼Ä´æÆ÷Ğ´1¸ö×Ö½ÚÊı¾İ
  // reg:16Î»¼Ä´æÆ÷µØÖ·,dat:´ıĞ´ÈëµÄÊı¾İ
  void Write_W5500_1Byte(u16 reg, u8 dat)
  {
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);   //Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(FDM1|RWB_WRITE|COMMON_R); //Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,1¸ö×Ö½ÚÊı¾İ³¤¶È,Ğ´Êı¾İ,Ñ¡ÔñÍ¨ÓÃ¼Ä´æÆ÷
  SPI1_Send_Byte(dat);  //Ğ´1¸ö×Ö½ÚÊı¾İ
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //À­¸ßCS  È¡ÏûÆ¬Ñ¡
  }
  
  
  
  
  //Í¨¹ıSPI1ÏòÖ¸¶¨µØÖ·¼Ä´æÆ÷Ğ´2¸ö×Ö½ÚÊı¾İ
  //reg:16Î»¼Ä´æÆ÷µØÖ·,dat:16Î»´ıĞ´ÈëµÄÊı¾İ(2¸ö×Ö½Ú)
  void Write_W5500_2Byte(u16 reg, u16 dat)
  {
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);//Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(FDM2|RWB_WRITE|COMMON_R);//Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,2¸ö×Ö½ÚÊı¾İ³¤¶È,Ğ´Êı¾İ,Ñ¡ÔñÍ¨ÓÃ¼Ä´æÆ÷
  SPI1_Send_Short(dat);//Ğ´16Î»Êı¾İ
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //À­¸ßCS  È¡ÏûÆ¬Ñ¡
  }
  
  
  
  
  //Í¨¹ıSPI1ÏòÖ¸¶¨µØÖ·¼Ä´æÆ÷Ğ´n¸ö×Ö½ÚÊı¾İ
  //reg:16Î»¼Ä´æÆ÷µØÖ·,*dat_ptr:´ıĞ´ÈëÊı¾İ»º³åÇøÖ¸Õë,size:´ıĞ´ÈëµÄÊı¾İ³¤¶È
  void Write_W5500_nByte(u16 reg, u8 *dat_ptr, u16 size)
  {
  u16 i;
  
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);//Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(VDM|RWB_WRITE|COMMON_R);//Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,N¸ö×Ö½ÚÊı¾İ³¤¶È,Ğ´Êı¾İ,Ñ¡ÔñÍ¨ÓÃ¼Ä´æÆ÷
  
  for(i=0;i<size;i++)//Ñ­»·½«»º³åÇøµÄsize¸ö×Ö½ÚÊı¾İĞ´ÈëW5500
  {
  SPI1_Send_Byte(*dat_ptr++);//Ğ´Ò»¸ö×Ö½ÚÊı¾İ
  }
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //À­¸ßCS  È¡ÏûÆ¬Ñ¡
  }
  
  
  
  
  //Í¨¹ıSPI1ÏòÖ¸¶¨¶Ë¿Ú¼Ä´æÆ÷Ğ´1¸ö×Ö½ÚÊı¾İ
  //s:¶Ë¿ÚºÅ,reg:16Î»¼Ä´æÆ÷µØÖ·,dat:´ıĞ´ÈëµÄÊı¾İ
  void Write_W5500_SOCK_1Byte(SOCKET s, u16 reg, u8 dat)
  {
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);//Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(FDM1|RWB_WRITE|(s*0x20+0x08));//Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,1¸ö×Ö½ÚÊı¾İ³¤¶È,Ğ´Êı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
  SPI1_Send_Byte(dat);//Ğ´1¸ö×Ö½ÚÊı¾İ
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //À­¸ßCS  È¡ÏûÆ¬Ñ¡
  }
  
  
  
  //Í¨¹ıSPI1ÏòÖ¸¶¨¶Ë¿Ú¼Ä´æÆ÷Ğ´2¸ö×Ö½ÚÊı¾İ
  //s:¶Ë¿ÚºÅ,reg:16Î»¼Ä´æÆ÷µØÖ·,dat:16Î»´ıĞ´ÈëµÄÊı¾İ(2¸ö×Ö½Ú)
  void Write_W5500_SOCK_2Byte(SOCKET s, u16 reg, u16 dat)
  {
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);//Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(FDM2|RWB_WRITE|(s*0x20+0x08));//Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,2¸ö×Ö½ÚÊı¾İ³¤¶È,Ğ´Êı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
  SPI1_Send_Short(dat);//Ğ´16Î»Êı¾İ
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //À­¸ßCS  È¡ÏûÆ¬Ñ¡
  }
  
  
  
  
  //Í¨¹ıSPI1ÏòÖ¸¶¨¶Ë¿Ú¼Ä´æÆ÷Ğ´4¸ö×Ö½ÚÊı¾İ
  //s:¶Ë¿ÚºÅ,reg:16Î»¼Ä´æÆ÷µØÖ·,*dat_ptr:´ıĞ´ÈëµÄ4¸ö×Ö½Ú»º³åÇøÖ¸Õë
  void Write_W5500_SOCK_4Byte(SOCKET s, u16 reg, u8 *dat_ptr)
  {
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//À­µÍCS CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);//Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(FDM4|RWB_WRITE|(s*0x20+0x08));//Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,4¸ö×Ö½ÚÊı¾İ³¤¶È,Ğ´Êı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
  
  SPI1_Send_Byte(*dat_ptr++);//Ğ´µÚ1¸ö×Ö½ÚÊı¾İ
  SPI1_Send_Byte(*dat_ptr++);//Ğ´µÚ2¸ö×Ö½ÚÊı¾İ
  SPI1_Send_Byte(*dat_ptr++);//Ğ´µÚ3¸ö×Ö½ÚÊı¾İ
  SPI1_Send_Byte(*dat_ptr++);//Ğ´µÚ4¸ö×Ö½ÚÊı¾İ
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS);//À­¸ßCS  È¡ÏûÆ¬Ñ¡
  }
  
  
  
  //¶ÁÈ¡W5500Ö¸¶¨µØÖ·¼Ä´æÆ÷µÄ1¸ö×Ö½ÚÊı¾İ
  //reg:16Î»¼Ä´æÆ÷µØÖ·
  //·µ»Ø:¶ÁÈ¡µ½¼Ä´æÆ÷µÄ1¸ö×Ö½ÚÊı¾İ
  u8 Read_W5500_1Byte(u16 reg)
  {
  u8 i;
  
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//À­µÍCS CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);  //Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(FDM1|RWB_READ|COMMON_R);//Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,1¸ö×Ö½ÚÊı¾İ³¤¶È,¶ÁÊı¾İ,Ñ¡ÔñÍ¨ÓÃ¼Ä´æÆ÷
  
  i=SPI_I2S_ReceiveData(SPI1);
  SPI1_Send_Byte(0x00);//·¢ËÍ¿ÕÊı¾İ µÈ´ı·µ»ØÊı¾İ
  i=SPI_I2S_ReceiveData(SPI1);//¶ÁÈ¡1¸ö×Ö½ÚÊı¾İ
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS);//À­¸ßCS  È¡ÏûÆ¬Ñ¡
  return i;//·µ»Ø¶ÁÈ¡µ½µÄ¼Ä´æÆ÷Êı¾İ
  }
  
  
  
  //¶ÁW5500Ö¸¶¨¶Ë¿Ú¼Ä´æÆ÷µÄ1¸ö×Ö½ÚÊı¾İ
  //s:¶Ë¿ÚºÅ,reg:16Î»¼Ä´æÆ÷µØÖ·
  //·µ»ØÖµ:¶ÁÈ¡µ½¼Ä´æÆ÷µÄ1¸ö×Ö½ÚÊı¾İ
  u8 Read_W5500_SOCK_1Byte(SOCKET s, u16 reg)
  {
  u8 i;
  
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//À­µÍCS CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);   //Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(FDM1|RWB_READ|(s*0x20+0x08));//Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,1¸ö×Ö½ÚÊı¾İ³¤¶È,¶ÁÊı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
  
  i=SPI_I2S_ReceiveData(SPI1);
  SPI1_Send_Byte(0x00);   //·¢ËÍ¿ÕÊı¾İ µÈ´ı·µ»ØÊı¾İ
  i=SPI_I2S_ReceiveData(SPI1);//¶ÁÈ¡1¸ö×Ö½ÚÊı¾İ
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS);  //À­¸ßCS  È¡ÏûÆ¬Ñ¡
  return i;//·µ»Ø¶ÁÈ¡µ½µÄ¼Ä´æÆ÷Êı¾İ
  }
  
  
  
  //¶ÁW5500Ö¸¶¨¶Ë¿Ú¼Ä´æÆ÷µÄ2¸ö×Ö½ÚÊı¾İ
  //s:¶Ë¿ÚºÅ,reg:16Î»¼Ä´æÆ÷µØÖ·
  //·µ»ØÖµ:¶ÁÈ¡µ½¼Ä´æÆ÷µÄ2¸ö×Ö½ÚÊı¾İ(16Î»)
  u16 Read_W5500_SOCK_2Byte(SOCKET s, u16 reg)
  {
  u16 i;
  
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//À­µÍCS CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(reg);//Í¨¹ıSPI1Ğ´16Î»¼Ä´æÆ÷µØÖ·
  SPI1_Send_Byte(FDM2|RWB_READ|(s*0x20+0x08));//Í¨¹ıSPI1Ğ´¿ØÖÆ×Ö½Ú,2¸ö×Ö½ÚÊı¾İ³¤¶È,¶ÁÊı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
  
  i=SPI_I2S_ReceiveData(SPI1);
  SPI1_Send_Byte(0x00);//·¢ËÍ¿ÕÊı¾İ µÈ´ı·µ»ØÊı¾İ
  i=SPI_I2S_ReceiveData(SPI1);//¶ÁÈ¡¸ßÎ»Êı¾İ
  SPI1_Send_Byte(0x00);//·¢ËÍ¿ÕÊı¾İ µÈ´ı·µ»ØÊı¾İ
  i*=256;
  i+=SPI_I2S_ReceiveData(SPI1);//¶ÁÈ¡µÍÎ»Êı¾İ
  
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS);//À­¸ßCS  È¡ÏûÆ¬Ñ¡
  return i;//·µ»Ø¶ÁÈ¡µ½µÄ¼Ä´æÆ÷Êı¾İ
  }
  
  
  
  
  //´ÓW5500½ÓÊÕÊı¾İ»º³åÇøÖĞ¶ÁÈ¡Êı¾İ
  //s:¶Ë¿ÚºÅ,*dat_ptr:Êı¾İ±£´æ»º³åÇøÖ¸Õë
  //·µ»ØÖµ:¶ÁÈ¡µ½µÄÊı¾İ³¤¶È,rx_size¸ö×Ö½Ú
  u16 Read_SOCK_Data_Buffer(SOCKET s, u8 *dat_ptr)
  {
  u16 rx_size;
  u16 offset, offset1;
  u16 i;
  u8 j;
  
  rx_size=Read_W5500_SOCK_2Byte(s,Sn_RX_RSR);
  if(rx_size==0) return 0;  //Ã»½ÓÊÕµ½Êı¾İÔò·µ»Ø
  if(rx_size>1460) rx_size=1460;
  
  offset=Read_W5500_SOCK_2Byte(s,Sn_RX_RD);
  offset1=offset;
  offset&=(S_RX_SIZE-1);    //¼ÆËãÊµ¼ÊµÄÎïÀíµØÖ·
  
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//À­µÍCS CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(offset);//Ğ´16Î»µØÖ·
  SPI1_Send_Byte(VDM|RWB_READ|(s*0x20+0x18));//Ğ´¿ØÖÆ×Ö½Ú,N¸ö×Ö½ÚÊı¾İ³¤¶È,¶ÁÊı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
  j=SPI_I2S_ReceiveData(SPI1);
  
  if((offset+rx_size)<S_RX_SIZE)//Èç¹û×î´óµØÖ·Î´³¬¹ıW5500½ÓÊÕ»º³åÇø¼Ä´æÆ÷µÄ×î´óµØÖ·
  {
  for(i=0;i<rx_size;i++)//Ñ­»·¶ÁÈ¡rx_size¸ö×Ö½ÚÊı¾İ
  {
  SPI1_Send_Byte(0x00);//·¢ËÍÒ»¸öÑÆÊı¾İ
  j=SPI_I2S_ReceiveData(SPI1);//¶ÁÈ¡1¸ö×Ö½ÚÊı¾İ
  *dat_ptr=j;//½«¶ÁÈ¡µ½µÄÊı¾İ±£´æµ½Êı¾İ±£´æ»º³åÇø
  dat_ptr++;//Êı¾İ±£´æ»º³åÇøÖ¸ÕëµØÖ·×ÔÔö1
  }
  }
  else//Èç¹û×î´óµØÖ·³¬¹ıW5500½ÓÊÕ»º³åÇø¼Ä´æÆ÷µÄ×î´óµØÖ·
  {
  offset=S_RX_SIZE-offset;
  for(i=0;i<offset;i++)//Ñ­»·¶ÁÈ¡³öÇ°offset¸ö×Ö½ÚÊı¾İ
  {
  SPI1_Send_Byte(0x00);//·¢ËÍÒ»¸öÑÆÊı¾İ
  j=SPI_I2S_ReceiveData(SPI1);//¶ÁÈ¡1¸ö×Ö½ÚÊı¾İ
  *dat_ptr=j;//½«¶ÁÈ¡µ½µÄÊı¾İ±£´æµ½Êı¾İ±£´æ»º³åÇø
  dat_ptr++;//Êı¾İ±£´æ»º³åÇøÖ¸ÕëµØÖ·×ÔÔö1
  }
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS);  //À­¸ßCS  È¡ÏûÆ¬Ñ¡
  
  GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//À­µÍCS CSÆ¬Ñ¡W5500
  
  SPI1_Send_Short(0x00);//Ğ´16Î»µØÖ·
  SPI1_Send_Byte(VDM|RWB_READ|(s*0x20+0x18));//Ğ´¿ØÖÆ×Ö½Ú,N¸ö×Ö½ÚÊı¾İ³¤¶È,¶ÁÊı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
  j=SPI_I2S_ReceiveData(SPI1);
  
  for(;i<rx_size;i++)//Ñ­»·¶ÁÈ¡ºórx_size-offset¸ö×Ö½ÚÊı¾İ
  {
  SPI1_Send_Byte(0x00);//·¢ËÍÒ»¸öÑÆÊı¾İ
  j=SPI_I2S_ReceiveData(SPI1);//¶ÁÈ¡1¸ö×Ö½ÚÊı¾İ
  *dat_ptr=j;//½«¶ÁÈ¡µ½µÄÊı¾İ±£´æµ½Êı¾İ±£´æ»º³åÇø
  dat_ptr++;//Êı¾İ±£´æ»º³åÇøÖ¸ÕëµØÖ·×ÔÔö1
  }
  }
  GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //À­¸ßCS  È¡ÏûÆ¬Ñ¡
  
  offset1+=rx_size;//¸üĞÂÊµ¼ÊÎïÀíµØÖ·,¼´ÏÂ´Î¶ÁÈ¡½ÓÊÕµ½µÄÊı¾İµÄÆğÊ¼µØÖ·
  Write_W5500_SOCK_2Byte(s, Sn_RX_RD, offset1);
  Write_W5500_SOCK_1Byte(s, Sn_CR, RECV);//·¢ËÍÆô¶¯½ÓÊÕÃüÁî
  return rx_size;//·µ»Ø½ÓÊÕµ½Êı¾İµÄ³¤¶È
I !> }
I !> 
I !> 
I !> void sendSocketNbuff(SOCKET s, u8 *dat_ptr, u16 size)
I !> {
I !> u16 offset,offset1;
I !> u16 i;
I !> 
I !> 
I !> //Sn_TX_WR :Socket n TX Write Pointer Register [R/W] [0x0024-0x0025] [0x0000]
I !> offset=Read_W5500_SOCK_2Byte(s,Sn_TX_WR);//offset có ??a ch? th?ng s0 Tx? ??a ch? th?ng này liên t?c thay ??i à?
I !> offset1=offset;// L?u ??a ch? này sang th?ng offset1??? l?y ?i?m ??u à?
I !> offset&=(S_TX_SIZE-1);//Calculate the actual physical address???? offset = offset & 0x7ff => ??m b?o ??a ch? ko bay ra ngoài khu 16k
I !> printf("offset 1:%d\r\n",offset);
I !> GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//Chip selection
I !> /* example:
I !> When the Host writes 5 Bytes Data (0x11, 0x22, 0x33, 0x44, 0x55) to Socket 1’s TX
I !> Buffer Block 0x0040 Address by using VDM mode, 5 bytes data are written with the
I !> SPI Frame below.*/
I !> //Write nBytes Data at Socketn’s TX Buffer Block 0xXXXX in VDM mode
I !> SPI1_Send_Short(offset);//Write 16-bit address : vi?t ??a ch? th?ng s0 Tx buffer xu?ng tr??c
I !> SPI1_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//Write control byte,NByte data length,Write data,Select port s register
I !> 
I !> if((offset+size)<S_TX_SIZE)//If the maximum address does not exceed the maximum address of the W5500 Transmit Buffer Register
I !> {
I !> for(i=0;i<size;i++)//Cyclicly write size bytes of data
I !> {
I !> SPI1_Send_Byte(*dat_ptr++);//Write one byte of data
I !> }
I !> }
I !> else//If the maximum address exceeds the maximum address of the W5500 Transmit Buffer Register
I !> {
I !> offset=S_TX_SIZE-offset;
I !> for(i=0;i<offset;i++)//Offset byte data before loop write
I !> {
I !> SPI1_Send_Byte(*dat_ptr++);//Write one byte of data
I !> }
I !> GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //Set the SCS of the W5500 to a high level
I !> 
I !> GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//Set the SCS of the W5500 to a low level
I !> 
I !> SPI1_Send_Short(0x00);//Write 16-bit address
I !> SPI1_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//Write control byte,NByte data length,Write data,Select port s register
I !> 
I !> for(;i<size;i++)//Loop write size-offset bytes of data
I !> {
I !> SPI1_Send_Byte(*dat_ptr++);//write one byte of data
I !> }
  }
  
I !> GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //Set the SCS of the W5500 to a high level
I !> delay_ms(1);
I !> 
I !> //offset1 ?ang ch?a ?i?m ??u, c?ng size ?? ra ?i?m cu?i? sau ?ó b?m g?i là t? bi?t ?o?n d? li?u h?????
I !> offset1+=size;//Update the actual physical address, that is, the starting address of the next time the data to be sent is sent to the transmit data buffer.
I !> Write_W5500_SOCK_2Byte(s, Sn_TX_WR, offset1);
  
  
D <! //½«Êı¾İĞ´ÈëW5500µÄÊı¾İ·¢ËÍ»º³åÇø
D <! //s:¶Ë¿ÚºÅ,*dat_ptr:Êı¾İ±£´æ»º³åÇøÖ¸Õë,size:´ıĞ´ÈëÊı¾İµÄ³¤¶È
I !> Write_W5500_SOCK_1Byte(s, Sn_CR, SEND);//Send start send command
I !> Write_W5500_SOCK_2Byte(s, Sn_TX_WR, 0);
I !> }
I !> // Write data to the W5500 data send buffer
I !> //s: port number, *dat_ptr: data save buffer pointer, size: length of data to be written
  void Write_SOCK_Data_Buffer(SOCKET s, u8 *dat_ptr, u16 size)
  {
  u16 offset,offset1;
  u16 i;
D <! 
D <! //Èç¹ûÊÇUDPÄ£Ê½,¿ÉÒÔÔÚ´ËÉèÖÃÄ¿µÄÖ÷»úµÄIPºÍ¶Ë¿ÚºÅ
D <! if((Read_W5500_SOCK_1Byte(s,Sn_MR)&0x0f) == MR_UDP)//Èç¹ûÊÇUDPÄ£Ê½½«½ÓÊÕµ½µÄÖ÷»úµØÖ·ºÍ¶Ë¿Ú¸üĞÂµ½Ä£¿é¶Ë¿ÚÖĞ
I !> //KO hi?u trong TCP mode th¨¬ th? n¨¤o?
I !> //If it is UDP mode, you can set the IP and port number of the destination host here.
I !> if((Read_W5500_SOCK_1Byte(s,Sn_MR)&0x0f) == MR_UDP)//If it is UDP mode, update the received host address and port to the module port.
  {
D <! Write_W5500_SOCK_4Byte(s, Sn_DIPR, UDP_DIPR);//ÉèÖÃÄ¿µÄÖ÷»úIP
D <! Write_W5500_SOCK_2Byte(s, Sn_DPORTR, UDP_DPORT[0]*256+UDP_DPORT[1]);//ÉèÖÃÄ¿µÄÖ÷»ú¶Ë¿ÚºÅ
I !> Write_W5500_SOCK_4Byte(s, Sn_DIPR, UDP_DIPR);//Set the destination IP
I !> Write_W5500_SOCK_2Byte(s, Sn_DPORTR, (UDP_DPORT[0]<<8)|+UDP_DPORT[1]);//Set the destination port
  }
  
D <! offset=Read_W5500_SOCK_2Byte(s,Sn_TX_WR);
D <! offset1=offset;
D <! offset&=(S_TX_SIZE-1);//¼ÆËãÊµ¼ÊµÄÎïÀíµØÖ·
I !> //Sn_TX_WR :Socket n TX Write Pointer Register [R/W] [0x0024-0x0025] [0x0000]
I !> offset=Read_W5500_SOCK_2Byte(s,Sn_TX_WR);//offset c¨® ??a ch? th?ng s0 Tx
I !> offset1=offset;// L?u ??a ch? n¨¤y sang th?ng offset1???
I !> offset&=(S_TX_SIZE-1);//Calculate the actual physical address???? offset = offset & 0x7ff => ??m b?o ??a ch? ko bay ra ngo¨¤i khu 16k
  
D <! GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//Æ¬Ñ¡À­µÍ
I !> GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//Chip selection
  
D <! SPI1_Send_Short(offset);//Ğ´16Î»µØÖ·
D <! SPI1_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//Ğ´¿ØÖÆ×Ö½Ú,N¸ö×Ö½ÚÊı¾İ³¤¶È,Ğ´Êı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
I !> SPI1_Send_Short(offset);//Write 16-bit address
I !> SPI1_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//Write control byte,NByte data length,Write data,Select port s register
  
D <! if((offset+size)<S_TX_SIZE)//Èç¹û×î´óµØÖ·Î´³¬¹ıW5500·¢ËÍ»º³åÇø¼Ä´æÆ÷µÄ×î´óµØÖ·
I !> if((offset+size)<S_TX_SIZE)//If the maximum address does not exceed the maximum address of the W5500 Transmit Buffer Register
  {
D <! for(i=0;i<size;i++)//Ñ­»·Ğ´Èësize¸ö×Ö½ÚÊı¾İ
I !> for(i=0;i<size;i++)//Cyclicly write size bytes of data
  {
D <! SPI1_Send_Byte(*dat_ptr++);//Ğ´ÈëÒ»¸ö×Ö½ÚµÄÊı¾İ
I !> SPI1_Send_Byte(*dat_ptr++);//Write one byte of data
  }
  }
D <! else//Èç¹û×î´óµØÖ·³¬¹ıW5500·¢ËÍ»º³åÇø¼Ä´æÆ÷µÄ×î´óµØÖ·
I !> else//If the maximum address exceeds the maximum address of the W5500 Transmit Buffer Register
  {
  offset=S_TX_SIZE-offset;
D <! for(i=0;i<offset;i++)//Ñ­»·Ğ´ÈëÇ°offset¸ö×Ö½ÚÊı¾İ
I !> for(i=0;i<offset;i++)//Offset byte data before loop write
  {
D <! SPI1_Send_Byte(*dat_ptr++);//Ğ´ÈëÒ»¸ö×Ö½ÚµÄÊı¾İ
I !> SPI1_Send_Byte(*dat_ptr++);//Write one byte of data
  }
D <! GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //ÖÃW5500µÄSCSÎª¸ßµçÆ½
I !> GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //Set the SCS of the W5500 to a high level
  
D <! GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//ÖÃW5500µÄSCSÎªµÍµçÆ½
I !> GPIO_ResetBits(W5500_SCS_GPIO, W5500_SCS);//Set the SCS of the W5500 to a low level
  
D <! SPI1_Send_Short(0x00);//Ğ´16Î»µØÖ·
D <! SPI1_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//Ğ´¿ØÖÆ×Ö½Ú,N¸ö×Ö½ÚÊı¾İ³¤¶È,Ğ´Êı¾İ,Ñ¡Ôñ¶Ë¿ÚsµÄ¼Ä´æÆ÷
I !> SPI1_Send_Short(0x00);//Write 16-bit address
I !> SPI1_Send_Byte(VDM|RWB_WRITE|(s*0x20+0x10));//Write control byte,NByte data length,Write data,Select port s register
  
D <! for(;i<size;i++)//Ñ­»·Ğ´Èësize-offset¸ö×Ö½ÚÊı¾İ
I !> for(;i<size;i++)//Loop write size-offset bytes of data
  {
D <! SPI1_Send_Byte(*dat_ptr++);//Ğ´ÈëÒ»¸ö×Ö½ÚµÄÊı¾İ
I !> SPI1_Send_Byte(*dat_ptr++);//write one byte of data
  }
  }
D <! GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //ÖÃW5500µÄSCSÎª¸ßµçÆ½
I !> GPIO_SetBits(W5500_SCS_GPIO, W5500_SCS); //Set the SCS of the W5500 to a high level
  
D <! offset1+=size;//¸üĞÂÊµ¼ÊÎïÀíµØÖ·,¼´ÏÂ´ÎĞ´´ı·¢ËÍÊı¾İµ½·¢ËÍÊı¾İ»º³åÇøµÄÆğÊ¼µØÖ·
I !> offset1+=size;//Update the actual physical address, that is, the starting address of the next time the data to be sent is sent to the transmit data buffer.
  Write_W5500_SOCK_2Byte(s, Sn_TX_WR, offset1);
D <! Write_W5500_SOCK_1Byte(s, Sn_CR, SEND);//·¢ËÍÆô¶¯·¢ËÍÃüÁî
I !> Write_W5500_SOCK_1Byte(s, Sn_CR, SEND);//Send start send command
  }
  
  
  
  //W5500Ó²¼ş¸´Î»
  //ËµÃ÷£ºW5500µÄ¸´Î»Òı½Å±£³ÖµÍµçÆ½ÖÁÉÙ500usÒÔÉÏ,²ÅÄÜÊ¹W5500½øÈë¸´Î»×´Ì¬
  void W5500_Hardware_Reset(void)
  {
  GPIO_ResetBits(W5500_RST_GPIO, W5500_RST);  //¸´Î»Òı½ÅÀ­µÍ
  delay_ms(50);
  GPIO_SetBits(W5500_RST_GPIO, W5500_RST);    //¸´Î»Òı½ÅÀ­¸ß
  delay_ms(200);
  while((Read_W5500_1Byte(PHYCFGR)&LINK)==0); //ËÀÑ­»·µÈ´ıÒÔÌ«ÍøÁ¬½ÓÍê³É	ÕâÀïÒª½«ÍøÏßÁ¬½Óµ½Â·ÓÉºÍÄ£¿éÉÏ ·ñÔò½«ÎŞ·¨Í¨¹ı
  }
  
  
  
  
D <! //³õÊ¼»¯W5500ÏàÓ¦¼Ä´æÆ÷
D <! //ËµÃ÷£ºÓ²¼ş³õÊ¼»¯ºóÒª¶ÔÆä½øĞĞÏàÓ¦Èí¼ş³õÊ¼»¯
I !> //Initialize the corresponding register of W5500
I !> //Description: After the hardware is initialized, it must be initialized accordingly.
  void W5500_Init(void)
  {
  u8 i=0;
I !> //MR (Mode Register) [R/W] [0x0000] [0x00]
I !> Write_W5500_1Byte(MR, RST);  //Software reset W5500, set to 1, automatically cleared after reset
I !> delay_ms(10);                //Delay 10ms
  
D <! Write_W5500_1Byte(MR, RST);  //Èí¼ş¸´Î»W5500,ÖÃ1ÓĞĞ§,¸´Î»ºó×Ô¶¯Çå0
D <! delay_ms(10);                //ÑÓÊ±10ms
D <! 
D <! //ÉèÖÃÍø¹Ø(Gateway)µÄIPµØÖ·,Gateway_IPÎª4×Ö½Ú
D <! //Ê¹ÓÃÍø¹Ø¿ÉÒÔÊ¹Í¨ĞÅÍ»ÆÆ×ÓÍøµÄ¾ÖÏŞ£¬Í¨¹ıÍø¹Ø¿ÉÒÔ·ÃÎÊµ½ÆäËü×ÓÍø»ò½øÈëInternet
I !> //Set the IP address of the gateway (Gateway) to 4 bytes.
I !> //Using a gateway allows communication to break through the limitations of subnets,
I !> //allowing access to other subnets or access through the gateway Internet
  Write_W5500_nByte(GAR, Gateway_IP, 4);
  
D <! //ÉèÖÃ×ÓÍøÑÚÂë(MASK)Öµ,SUB_MASKÎª4×Ö½Ú
D <! //×ÓÍøÑÚÂëÓÃÓÚ×ÓÍøÔËËã
I !> //Set the subnet mask (MASK) value, SUB_MASK is 4 bytes
I !> //Subnet mask for subnet operations
  Write_W5500_nByte(SUBR,Sub_Mask,4);
  
D <! //ÉèÖÃÎïÀíµØÖ·,PHY_ADDRÎª6×Ö½Ú,ÓÃÓÚÎ¨Ò»±êÊ¶ÍøÂçÉè±¸µÄÎïÀíµØÖ·Öµ
D <! //¸ÃµØÖ·ÖµĞèÒªµ½IEEEÉêÇë£¬°´ÕÕOUIµÄ¹æ¶¨£¬Ç°3¸ö×Ö½ÚÎª³§ÉÌ´úÂë£¬ºóÈı¸ö×Ö½ÚÎª²úÆ·ĞòºÅ
D <! //Èç¹û×Ô¼º¶¨ÒåÎïÀíµØÖ·£¬×¢ÒâµÚÒ»¸ö×Ö½Ú±ØĞëÎªÅ¼Êı
I !> //Set physical address,PHY_ADDR 6 bytes,Used to uniquely identify the physical address value of a network device
I !> //The address value needs to be applied to the IEEE,According to the OUI regulations, the first 3 bytes are the vendor code, and the last three bytes are the product serial number.
I !> //If you define your own physical address, note that the first byte must be even
  Write_W5500_nByte(SHAR,Phy_Addr,6);
  
D <! //ÉèÖÃ±¾»úµÄIPµØÖ·,IP_ADDRÎª4×Ö½Ú
D <! //×¢Òâ£¬Íø¹ØIP±ØĞëÓë±¾»úIPÊôÓÚÍ¬Ò»¸ö×ÓÍø£¬·ñÔò±¾»ú½«ÎŞ·¨ÕÒµ½Íø¹Ø
I !> //Set the IP address of this machine,IP_ADDR is 4 bytes
I !> //Note that the gateway IP must belong to the same subnet as the local IP, otherwise the local machine will not be able to find the gateway.
  Write_W5500_nByte(SIPR,IP_Addr,4);
  
D <! //ÉèÖÃ·¢ËÍ»º³åÇøºÍ½ÓÊÕ»º³åÇøµÄ´óĞ¡£¬²Î¿¼W5500Êı¾İÊÖ²á ³õÊ¼»¯·Ö±ğÅäÖÃÎª2k ×Ü¹²Îª16k
I !> //Set the size of the send buffer and receive buffer,Refer to the W5500 data sheet. Initialization is configured to 2k for a total of 16k.
  for(i=0;i<8;i++)
  {
  Write_W5500_SOCK_1Byte(i,Sn_RXBUF_SIZE, 0x02);//Socket Rx memory size=2k
  Write_W5500_SOCK_1Byte(i,Sn_TXBUF_SIZE, 0x02);//Socket Tx mempry size=2k
  }
  
D <! //ÉèÖÃÖØÊÔÊ±¼ä£¬Ä¬ÈÏÎª2000(200ms)
D <! //Ã¿Ò»µ¥Î»ÊıÖµÎª100Î¢Ãë,³õÊ¼»¯Ê±ÖµÉèÎª2000(0x07D0),µÈÓÚ200ºÁÃë
I !> //Set the retry time, the default is 2000(200ms)
I !> //The value of each unit is 100 microseconds, and the value at initialization is set to 2000 (0x07D0), equal to 200 milliseconds.
  Write_W5500_2Byte(RTR, 0x07d0);
  
D <! //ÉèÖÃÖØÊÔ´ÎÊı£¬Ä¬ÈÏÎª8´Î
D <! //Èç¹ûÖØ·¢µÄ´ÎÊı³¬¹ıÉè¶¨Öµ,Ôò²úÉú³¬Ê±ÖĞ¶Ï(Ïà¹ØµÄ¶Ë¿ÚÖĞ¶Ï¼Ä´æÆ÷ÖĞµÄSn_IR ³¬Ê±Î»(TIMEOUT)ÖÃ¡°1¡±)
I !> //Set the number of retries, the default is 8 times
I !> //If the number of retransmissions exceeds the set value, a timeout interrupt is generated (the Sn_IR timeout bit (TIMEOUT) in the associated port interrupt register is set to "1")
  Write_W5500_1Byte(RCR,8);
  
D <! //Æô¶¯ÖĞ¶Ï£¬²Î¿¼W5500Êı¾İÊÖ²áÈ·¶¨×Ô¼ºĞèÒªµÄÖĞ¶ÏÀàĞÍ
D <! //IMR_CONFLICTÊÇIPµØÖ·³åÍ»Òì³£ÖĞ¶Ï,IMR_UNREACHÊÇUDPÍ¨ĞÅÊ±£¬µØÖ·ÎŞ·¨µ½´ïµÄÒì³£ÖĞ¶Ï
D <! //ÆäËüÊÇSocketÊÂ¼şÖĞ¶Ï£¬¸ù¾İĞèÒªÌí¼Ó
D <! Write_W5500_1Byte(IMR,IM_IR7 | IM_IR6);	//ÖĞ¶ÏÔÊĞí¼Ä´æÆ÷
D <! Write_W5500_1Byte(SIMR,S0_IMR);			//socketÖĞ¶Ï×´Ì¬0-7 ¼Ä´æÆ÷ÅäÖÃÔÚS0ÉÏ
D <! Write_W5500_SOCK_1Byte(0, Sn_IMR, IMR_SENDOK | IMR_TIMEOUT | IMR_RECV | IMR_DISCON | IMR_CON);	//S0 ÖĞ¶Ï¹¦ÄÜÈ«²¿´ò¿ª
I !> //Start the interrupt, refer to the W5500 data sheet to determine the type of interrupt you need.
I !> //IMR_CONFLICT is an abnormal interruption of IP address conflict, IMR_UNREACH is an abnormal interruption of address unreachable when UDP communication
I !> //Others are Socket event interrupts, add as needed
I !> Write_W5500_1Byte(IMR,IM_IR7 | IM_IR6);	//IP Conflict Interrupt Mask | Destination unreachable Interrupt Mask
I !> Write_W5500_1Byte(SIMR,S0_IMR);			//socket Interrupt on S0
I !> Write_W5500_SOCK_1Byte(S0, Sn_IMR, IMR_SENDOK | IMR_RECV);	//S0 Interrupt SEND command is completed, whenever data is received from a peer.
  }
  
  
  
  
D <! //¼ì²éÍø¹Ø·şÎñÆ÷
D <! //ÊôÓÚÄ£ÄâÒ»¶Ë¿ÚµÄÏàÓ¦²Ù×÷£¬ÅĞ¶ÏW5500Ä£Ê½ÊÇ·ñ½øÈë¿ÉÒÔÍ¨Ñ¶×´Ì¬¡£
D <! //·µ»ØÖµ:³É¹¦·µ»ØTRUE(0xFF),Ê§°Ü·µ»ØFALSE(0x00)
I !> //Check the gateway server
I !> //It belongs to the corresponding operation of the analog one port, and judges whether the W5500 mode enters the communicable state.
I !> //Return value: TRUE (0xFF) is returned successfully, FALSE (0x00) is returned.
  u8 Detect_Gateway(void)
  {
  u8 ip_adde[4];
  ip_adde[0]=IP_Addr[0]+1;
  ip_adde[1]=IP_Addr[1]+1;
  ip_adde[2]=IP_Addr[2]+1;
  ip_adde[3]=IP_Addr[3]+1;
  
D <! //¼ì²éÍø¹Ø¼°»ñÈ¡Íø¹ØµÄÎïÀíµØÖ·
D <! Write_W5500_SOCK_4Byte(0,Sn_DIPR,ip_adde);//ÏòÄ¿µÄµØÖ·¼Ä´æÆ÷Ğ´ÈëÓë±¾»úIP²»Í¬µÄIPÖµ
D <! Write_W5500_SOCK_1Byte(0,Sn_MR,MR_TCP);   //ÉèÖÃsocketÎªTCPÄ£Ê½
D <! Write_W5500_SOCK_1Byte(0,Sn_CR,OPEN);     //´ò¿ªSocket
D <! delay_ms(5);//ÑÓÊ±5ms
I !> //Check the gateway and get the physical address of the gateway
I !> //Socket n Destination Port Register
I !> Write_W5500_SOCK_4Byte(S0,Sn_DIPR,ip_adde);//Write a different IP value to the destination address register than the local IP address
I !> Write_W5500_SOCK_1Byte(S0,Sn_MR,MR_TCP);   //Set the socket to TCP mode.
I !> Write_W5500_SOCK_1Byte(S0,Sn_CR,OPEN);     //Open Socket
I !> delay_ms(5);//Delay 5ms
  
D <! if(Read_W5500_SOCK_1Byte(0,Sn_SR) != SOCK_INIT)//Èç¹ûsocket´ò¿ªÊ§°Ü	 ¼´Æô¶¯TCPÄ£Ê½Ê§°Ü
I !> if(Read_W5500_SOCK_1Byte(S0,Sn_SR) != SOCK_INIT)//If the socket fails to open, the TCP mode fails to start.
  {
D <! Write_W5500_SOCK_1Byte(0,Sn_CR,CLOSE);//´ò¿ª²»³É¹¦,¹Ø±ÕSocket
D <! return FALSE;//·µ»ØFALSE(0x00)
I !> Write_W5500_SOCK_1Byte(S0,Sn_CR,CLOSE);//Open unsuccessful, close Socket
I !> return FALSE;//Return FALSE(0x00)
  }
  
D <! Write_W5500_SOCK_1Byte(0,Sn_CR,CONNECT);//ÉèÖÃSocketÎªConnectÄ£Ê½	TCP×÷Îª¿Í»§¶Ë
I !> Write_W5500_SOCK_1Byte(S0,Sn_CR,CONNECT);//Set Socket to Connect mode TCP as client
  
  do
  {
  u8 j=0;
D <! j=Read_W5500_SOCK_1Byte(0,Sn_IR);//¶ÁÈ¡Socket0ÖĞ¶Ï±êÖ¾¼Ä´æÆ÷
D <! if(j!=0)						 //Èç¹ûÓĞÖĞ¶ÏÌáÊ¾ ÔòĞ´1Çå¶ÔÓ¦ÖĞ¶Ï
D <! Write_W5500_SOCK_1Byte(0,Sn_IR,j);
D <! delay_ms(5);//ÑÓÊ±5ms
D <! if((j&IR_TIMEOUT) == IR_TIMEOUT) //³¬Ê±
I !> j=Read_W5500_SOCK_1Byte(S0,Sn_IR);//Read Socket0 interrupt flag register
I !> //If there is an interrupt prompt, write 1 clear corresponding interrupt
I !> if(j!=0) Write_W5500_SOCK_1Byte(S0,Sn_IR,j);
I !> delay_ms(5);
I !> if((j&IR_TIMEOUT) == IR_TIMEOUT) //time out
  {
  return FALSE;
  }
D <! else if(Read_W5500_SOCK_1Byte(0,Sn_DHAR) != 0xff)	 //Ö»ÅĞ¶ÏÄ©Î»MAC ÊÇ·ñÎªFF Èç¹û³É¹¦¼ÓÔØÕâÀïÓ¦²»ÎªFF
I !> else if(Read_W5500_SOCK_1Byte(S0,Sn_DHAR) != 0xff)	 //Only judge whether the last MAC is FF. If it is successfully loaded, it should not be FF.
  {
D <! Write_W5500_SOCK_1Byte(0,Sn_CR,CLOSE);//¹Ø±ÕSocket	   ËµÃ÷²âÊÔ³É¹¦
I !> Write_W5500_SOCK_1Byte(S0,Sn_CR,CLOSE);//Close Socket Description Test successful
  return TRUE;
  }
  }while(1);
  }
  
  
  
  
D <! //Ö¸¶¨Socket(0~7)³õÊ¼»¯
D <! //s:´ı³õÊ¼»¯µÄ¶Ë¿Ú
I !> //Specify Socket (0~7) initialization
I !> //s:Port to be initialized
  void Socket_Init(SOCKET s)
  {
D <! //ÉèÖÃ·ÖÆ¬³¤¶È£¬²Î¿¼W5500Êı¾İÊÖ²á£¬¸ÃÖµ¿ÉÒÔ²»ĞŞ¸Ä
D <! Write_W5500_SOCK_2Byte(0, Sn_MSSR, 1460);//×î´ó·ÖÆ¬×Ö½ÚÊı=1460(0x5b4)
D <! //ÉèÖÃÖ¸¶¨¶Ë¿Ú
I !> //Set the fragment length, refer to the W5500 data sheet, the value can be modified.
I !> //(Socket n Maximum Segment Size Register) [R/W] [0x0012-0x0013] [0x0000]
I !> /*This register is used for MSS (Maximum Segment Size) of TCP, and the register displays MSS set by the other party when TCP is activated in Passive Mode.
I !> */
I !> //Write_W5500_SOCK_2Byte(S0, Sn_MSSR, 1460);//Maximum number of fragmented bytes =1460(0x5b4)
I !> //Set the specified port
  switch(s)
  {
  case 0:
D <! //ÉèÖÃ¶Ë¿Ú0µÄ¶Ë¿ÚºÅ
D <! Write_W5500_SOCK_2Byte(0, Sn_PORT, S0_Port[0]*256+S0_Port[1]);
D <! //ÉèÖÃ¶Ë¿Ú0Ä¿µÄ(Ô¶³Ì)¶Ë¿ÚºÅ
D <! Write_W5500_SOCK_2Byte(0, Sn_DPORTR, S0_DPort[0]*256+S0_DPort[1]);
D <! //ÉèÖÃ¶Ë¿Ú0Ä¿µÄ(Ô¶³Ì)IPµØÖ·
D <! Write_W5500_SOCK_4Byte(0, Sn_DIPR, S0_DIP);
I !> //Sn_PORT configures the source port number of Socket n.
I !> Write_W5500_SOCK_2Byte(0, Sn_PORT, (S0_Port[0]<<8)|S0_Port[1]);
I !> 
I !> //Set port 0 destination (remote) port number
I !> //Write_W5500_SOCK_2Byte(0, Sn_DPORTR, S0_DPort[0]*256+S0_DPort[1]);
I !> //Set port 0 destination (remote) IP address
I !> //Write_W5500_SOCK_4Byte(0, Sn_DIPR, S0_DIP);
  
  break;
  
  case 1:
  break;
  
  case 2:
  break;
  
  case 3:
  break;
  
  case 4:
  break;
  
  case 5:
  break;
  
  case 6:
  break;
  
  case 7:
  break;
  
  default:
  break;
  }
  }
  
  
  
  //ÉèÖÃÖ¸¶¨Socket(0~7)Îª¿Í»§¶ËÓëÔ¶³Ì·şÎñÆ÷Á¬½Ó
  //s:´ıÉè¶¨µÄ¶Ë¿Ú
  //·µ»ØÖµ:³É¹¦·µ»ØTRUE(0xFF),Ê§°Ü·µ»ØFALSE(0x00)
  //ËµÃ÷  :µ±±¾»úSocket¹¤×÷ÔÚ¿Í»§¶ËÄ£Ê½Ê±,ÒıÓÃ¸Ã³ÌĞò,ÓëÔ¶³Ì·şÎñÆ÷½¨Á¢Á¬½Ó
  //	     Èç¹ûÆô¶¯Á¬½Óºó³öÏÖ³¬Ê±ÖĞ¶Ï£¬ÔòÓë·şÎñÆ÷Á¬½ÓÊ§°Ü,ĞèÒªÖØĞÂµ÷ÓÃ¸Ã³ÌĞòÁ¬½Ó
  //	     ¸Ã³ÌĞòÃ¿µ÷ÓÃÒ»´Î,¾ÍÓë·şÎñÆ÷²úÉúÒ»´ÎÁ¬½Ó
  u8 Socket_Connect(SOCKET s)
  {
  Write_W5500_SOCK_1Byte(s,Sn_MR,MR_TCP);//ÉèÖÃsocketÎªTCPÄ£Ê½
  Write_W5500_SOCK_1Byte(s,Sn_CR,OPEN);//´ò¿ªSocket
  delay_ms(5);//ÑÓÊ±5ms
  if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_INIT)//Èç¹ûsocket´ò¿ªÊ§°Ü
  {
  Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//´ò¿ª²»³É¹¦,¹Ø±ÕSocket
  return FALSE;//·µ»ØFALSE(0x00)
  }
  Write_W5500_SOCK_1Byte(s,Sn_CR,CONNECT);//ÉèÖÃSocketÎªConnectÄ£Ê½
  return TRUE;//·µ»ØTRUE,ÉèÖÃ³É¹¦
  }
  
  
  
  
  //ÉèÖÃÖ¸¶¨Socket(0~7)×÷Îª·şÎñÆ÷µÈ´ıÔ¶³ÌÖ÷»úµÄÁ¬½Ó
  //s:´ıÉè¶¨µÄ¶Ë¿Ú
  //·µ»ØÖµ:³É¹¦·µ»ØTRUE(0xFF),Ê§°Ü·µ»ØFALSE(0x00)
  //ËµÃ÷  :µ±±¾»úSocket¹¤×÷ÔÚ·şÎñÆ÷Ä£Ê½Ê±,ÒıÓÃ¸Ã³ÌĞò,µÈµÈÔ¶³ÌÖ÷»úµÄÁ¬½Ó
  //		 ¸Ã³ÌĞòÖ»µ÷ÓÃÒ»´Î,¾ÍÊ¹W5500ÉèÖÃÎª·şÎñÆ÷Ä£Ê½
  u8 Socket_Listen(SOCKET s)
  {
  Write_W5500_SOCK_1Byte(s,Sn_MR,MR_TCP);//ÉèÖÃsocketÎªTCPÄ£Ê½
  Write_W5500_SOCK_1Byte(s,Sn_CR,OPEN);//´ò¿ªSocket
  delay_ms(5);//ÑÓÊ±5ms
  if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_INIT)//Èç¹ûsocket´ò¿ªÊ§°Ü
  {
  Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//´ò¿ª²»³É¹¦,¹Ø±ÕSocket
  return FALSE;//·µ»ØFALSE(0x00)
  }
  Write_W5500_SOCK_1Byte(s,Sn_CR,LISTEN);//ÉèÖÃSocketÎªÕìÌıÄ£Ê½
  delay_ms(5);//ÑÓÊ±5ms
  if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_LISTEN)//Èç¹ûsocketÉèÖÃÊ§°Ü
  {
  Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//ÉèÖÃ²»³É¹¦,¹Ø±ÕSocket
  return FALSE;//·µ»ØFALSE(0x00)
  }
  
  return TRUE;
  
  //ÖÁ´ËÍê³ÉÁËSocketµÄ´ò¿ªºÍÉèÖÃÕìÌı¹¤×÷,ÖÁÓÚÔ¶³Ì¿Í»§¶ËÊÇ·ñÓëËü½¨Á¢Á¬½Ó,ÔòĞèÒªµÈ´ıSocketÖĞ¶Ï£¬
  //ÒÔÅĞ¶ÏSocketµÄÁ¬½ÓÊÇ·ñ³É¹¦¡£²Î¿¼W5500Êı¾İÊÖ²áµÄSocketÖĞ¶Ï×´Ì¬
  //ÔÚ·şÎñÆ÷ÕìÌıÄ£Ê½²»ĞèÒªÉèÖÃÄ¿µÄIPºÍÄ¿µÄ¶Ë¿ÚºÅ
  }
  
  
  
  
  
D <! //ÉèÖÃÖ¸¶¨Socket(0~7)ÎªUDPÄ£Ê½
D <! //s:´ıÉè¶¨µÄ¶Ë¿Ú
D <! //·µ»ØÖµ:³É¹¦·µ»ØTRUE(0xFF),Ê§°Ü·µ»ØFALSE(0x00)
D <! //ËµÃ÷  :Èç¹ûSocket¹¤×÷ÔÚUDPÄ£Ê½,ÒıÓÃ¸Ã³ÌĞò,ÔÚUDPÄ£Ê½ÏÂ,SocketÍ¨ĞÅ²»ĞèÒª½¨Á¢Á¬½Ó
D <! //		 ¸Ã³ÌĞòÖ»µ÷ÓÃÒ»´Î£¬¾ÍÊ¹W5500ÉèÖÃÎªUDPÄ£Ê½
D <! u8 Socket_UDP(SOCKET s)
I !> // Set the specified Socket (0 ~ 7) to UDP mode
I !> // s: the port to be set
I !> // Return value: success returns TRUE (0xFF), failure returns FALSE (0x00)
I !> // Description: If the Socket works in UDP mode, refer to the program, in UDP mode, Socket communication does not need to establish a connection
I !> // The program is called only once, setting W5500 to UDP mode.
I !> // Should be add Sn's port to argument of this function
I !> u8 Socket2UDP(SOCKET s)
I !> {//phai sua lai cho nay nhe >>>>>>>>>>>day
I !> Write_W5500_SOCK_2Byte(s, Sn_PORT, (S0_Port[0]<<8)|S0_Port[1]); //It should be set before OPEN command is ordered.
I !> //Sn_MR configures the option or protocol type of Socket n.
I !> Write_W5500_SOCK_1Byte(s,Sn_MR,MR_UDP); //Set Socket to UDP mode
I !> //(Socket n Command Register) [R/W] [0x0001] [0x00]
I !> Write_W5500_SOCK_1Byte(s,Sn_CR,OPEN);//Socket n is initialized and opened
I !> delay_ms(5);
I !> //Check Socket n Status Register [R] [0x0003] [0x00]
I !> if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_UDP)//This indicates Socket n is opened in UDP mode
  {
D <! Write_W5500_SOCK_1Byte(s,Sn_MR,MR_UDP);//ÉèÖÃSocketÎªUDPÄ£Ê½*/
D <! Write_W5500_SOCK_1Byte(s,Sn_CR,OPEN);//´ò¿ªSocket*/
D <! delay_ms(5);//Write data low);//ÑÓÊ±5ms
D <! if(Read_W5500_SOCK_1Byte(s,Sn_SR)!=SOCK_UDP)//Èç¹ûSocket´ò¿ªÊ§°Ü
D <! {
D <! Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//´ò¿ª²»³É¹¦,¹Ø±ÕSocket
D <! return FALSE;//·µ»ØFALSE(0x00)
I !> Write_W5500_SOCK_1Byte(s,Sn_CR,CLOSE);//Open unsuccessful, close Socket
I !> return FALSE;//FALSE(0x00)
  }
  else
  return TRUE;
  
D <! //ÖÁ´ËÍê³ÉÁËSocketµÄ´ò¿ªºÍUDPÄ£Ê½ÉèÖÃ,ÔÚÕâÖÖÄ£Ê½ÏÂËü²»ĞèÒªÓëÔ¶³ÌÖ÷»ú½¨Á¢Á¬½Ó
D <! //ÒòÎªSocket²»ĞèÒª½¨Á¢Á¬½Ó,ËùÒÔÔÚ·¢ËÍÊı¾İÇ°¶¼¿ÉÒÔÉèÖÃÄ¿µÄÖ÷»úIPºÍÄ¿µÄSocketµÄ¶Ë¿ÚºÅ
D <! //Èç¹ûÄ¿µÄÖ÷»úIPºÍÄ¿µÄSocketµÄ¶Ë¿ÚºÅÊÇ¹Ì¶¨µÄ,ÔÚÔËĞĞ¹ı³ÌÖĞÃ»ÓĞ¸Ä±ä,ÄÇÃ´Ò²¿ÉÒÔÔÚÕâÀïÉèÖÃ
I !> // This completes the Socket open and UDP mode settings, in this mode it does not need to establish a connection with the remote host
I !> // Because Socket does not need to establish a connection, so you can set the destination host IP and destination Socket port number before sending data
I !> // If the destination host IP and the destination Socket port number is fixed, there is no change during the running, then you can also set here
  }
  
  
  
  
  
D <! //º¯ÊıÃû:W5500_Interrupt_Process
D <! //ÃèÊö  :W5500ÖĞ¶Ï´¦Àí³ÌĞò¿ò¼Ü
  void W5500_Interrupt_Process(void)
  {
  u8 i,j;
I !> 
  
D <! IntDispose:
D <! W5500_Interrupt=0;//ÇåÁãÖĞ¶Ï±êÖ¾
D <! i = Read_W5500_1Byte(IR);//¶ÁÈ¡ÖĞ¶Ï±êÖ¾¼Ä´æÆ÷
D <! Write_W5500_1Byte(IR, (i&0xf0));//»ØĞ´Çå³ıÖĞ¶Ï±êÖ¾
I !> W5500_Interrupt=0;//Clear flag interrupt
I !> /*IR indicates the interrupt status. Each bit of IR can be cleared when the host writes
I !> ??value to each bit. If IR is not equal to ?x00? INTn PIN is asserted low until it is ?x00?*/
I !> i = Read_W5500_1Byte(IR);//read interrupt
I !> Write_W5500_1Byte(IR, (i&0xf0));//clear interrupt
  
D <! //	if((i & CONFLICT) == CONFLICT)//IPµØÖ·³åÍ»Òì³£´¦Àí
D <! //	{
D <! //		 //×Ô¼ºÌí¼Ó´úÂë
D <! //	}
D <! //
D <! //	if((i & UNREACH) == UNREACH)//UDPÄ£Ê½ÏÂµØÖ·ÎŞ·¨µ½´ïÒì³£´¦Àí
D <! //	{
D <! //		//×Ô¼ºÌí¼Ó´úÂë
D <! //	}
I !> if((i & CONFLICT) == CONFLICT)
I !> {
I !> printf("INT: IP conflict\r\n");
I !> }
  
D <! i=Read_W5500_1Byte(SIR);//¶ÁÈ¡¶Ë¿ÚÖĞ¶Ï±êÖ¾¼Ä´æÆ÷
D <! if((i & S0_INT) == S0_INT)//Socket0ÊÂ¼ş´¦Àí
I !> if((i & UNREACH) == UNREACH)
I !> {
I !> printf("INT: IP UNREACH\r\n");
I !> }
I !> ProcessSocket0Int:
I !> i=Read_W5500_1Byte(SIR);//read interrupt, (Interrupt Mask Register) [R/W][0x0016][0x00]
I !> if((i & S0_INT) == S0_INT)//Socket0 Interrupt
  {
D <! j=Read_W5500_SOCK_1Byte(0,Sn_IR); //¶ÁÈ¡Socket0ÖĞ¶Ï±êÖ¾¼Ä´æÆ÷
D <! Write_W5500_SOCK_1Byte(0,Sn_IR,j);//»ØĞ´Çå³ıÖĞ¶Ï±êÖ¾
I !> j=Read_W5500_SOCK_1Byte(0,Sn_IR); //(Socket n Interrupt Register) [RCW1] [0x0002] [0x00]
I !> Write_W5500_SOCK_1Byte(0,Sn_IR,j);//clear interrupt
  
D <! if(j&IR_CON)//ÔÚTCPÄ£Ê½ÏÂ,Socket0³É¹¦Á¬½Ó
I !> if(j&IR_CON)////when the connection with peer is successful and then Sn_SR is changed to SOCK_ESTABLISHED.
  {
D <! S0_State|=S_CONN;//ÍøÂçÁ¬½Ó×´Ì¬0x02,¶Ë¿ÚÍê³ÉÁ¬½Ó£¬¿ÉÒÔÕı³£´«ÊäÊı¾İ
I !> S0_State|=S_CONN;
I !> printf("INT: SOCK_ESTABLISHED\r\n");
  }
D <! if(j&IR_DISCON)//ÔÚTCPÄ£Ê½ÏÂSocket¶Ï¿ªÁ¬½Ó´¦Àí
I !> if(j&IR_DISCON)//when FIN or FIN/ACK packet is received from a peer.
  {
D <! Write_W5500_SOCK_1Byte(0,Sn_CR,CLOSE);//¹Ø±Õ¶Ë¿Ú,µÈ´ıÖØĞÂ´ò¿ªÁ¬½Ó
D <! Socket_Init(0);		//Ö¸¶¨Socket(0~7)³õÊ¼»¯,³õÊ¼»¯¶Ë¿Ú0
D <! S0_State=0;//ÍøÂçÁ¬½Ó×´Ì¬0x00,¶Ë¿ÚÁ¬½ÓÊ§°Ü
I !> Write_W5500_SOCK_1Byte(0,Sn_CR,CLOSE);
I !> Socket_Init(0);
I !> S0_State = S_Unknown;
I !> printf("INT: IR_DISCON\r\n");
  }
D <! if(j&IR_SEND_OK)//Socket0Êı¾İ·¢ËÍÍê³É,¿ÉÒÔÔÙ´ÎÆô¶¯S_tx_process()º¯Êı·¢ËÍÊı¾İ
I !> if(j&IR_SEND_OK)//Socket0 SEND command is completed.
  {
D <! S0_Data|=S_TRANSMITOK;//¶Ë¿Ú·¢ËÍÒ»¸öÊı¾İ°üÍê³É
I !> S0_Data|=S_TRANSMITOK;
I !> printf("INT: SEND OK\r\n");
  }
D <! if(j&IR_RECV)//Socket½ÓÊÕµ½Êı¾İ,¿ÉÒÔÆô¶¯S_rx_process()º¯Êı
I !> if(j&IR_RECV)//whenever data is received from a peer.
  {
D <! S0_Data|=S_RECEIVE;//¶Ë¿Ú½ÓÊÕµ½Ò»¸öÊı¾İ°ü
I !> S0_Data|=S_RECEIVE;
I !> printf("INT: data is received\r\n");
  }
D <! if(j&IR_TIMEOUT)//SocketÁ¬½Ó»òÊı¾İ´«Êä³¬Ê±´¦Àí
I !> if(j&IR_TIMEOUT)//when ARP or TCP TIMEOUT occurs.
  {
D <! Write_W5500_SOCK_1Byte(0,Sn_CR,CLOSE);// ¹Ø±Õ¶Ë¿Ú,µÈ´ıÖØĞÂ´ò¿ªÁ¬½Ó
D <! S0_State=0;//ÍøÂçÁ¬½Ó×´Ì¬0x00,¶Ë¿ÚÁ¬½ÓÊ§°Ü
I !> Write_W5500_SOCK_1Byte(0,Sn_CR,CLOSE);
I !> S0_State = S_Unknown;
I !> printf("INT: TIMEOUT\r\n");
  }
  }
  
  if(Read_W5500_1Byte(SIR) != 0)
D <! goto IntDispose;
I !> goto ProcessSocket0Int;
  }
  
